# -*- coding: utf-8 -*-
"""most_profitable_patrons.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1eXGdsvLE6IRzVvY48dBlQ1VpX70mwYfH

This report will use machine learning to identify the classified patrons which NYC cabs should identify as most profitable.
Will use January 2024 data.

K-means and/or higherarchical clustering will be implemented.
"""

from pyarrow import parquet as pq
import pandas as pd
import numpy as np
from matplotlib import pyplot as plt
from sklearn.model_selection import train_test_split
from sklearn.cluster import KMeans
from datetime import datetime

# import data cell
!file yellow_tripdata_2024-01.parquet
yellow_table = pq.read_table('yellow_tripdata_2024-01.parquet')
ytp = yellow_table.to_pandas()

from google.colab import data_table
data_table.DataTable(ytp)

# clean values
min_dt = datetime(2024, 1, 1)
min_ta = 0
max_td = 1000
min_pa = 1

# convert to types
ytp['tpep_pickup_datetime'] = pd.to_datetime(ytp['tpep_pickup_datetime'])
ytp['total_amount'] = pd.to_numeric(ytp['total_amount'])
ytp['trip_distance'] = pd.to_numeric(ytp['trip_distance'])
ytp['trip_distance'] = pd.to_numeric(ytp['passenger_count'])

# clear too early, negative amounts
temp = ytp['tpep_pickup_datetime']
ytp['tpep_pickup_datetime'] = temp.mask(temp<min_dt,np.NaN)
temp = ytp['total_amount']
ytp['total_amount'] = temp.mask(temp<min_ta,np.NaN)
temp = ytp['trip_distance']
ytp['trip_distance'] = temp.mask(temp>max_td,np.NaN)
temp = ytp['passenger_count']
ytp['passenger_count'] = temp.mask(temp<min_pa,np.NaN)

# drop empty
ytp.dropna(subset=['tpep_pickup_datetime','total_amount','trip_distance','passenger_count'], inplace=True)

X = ytp[['VendorID','tpep_pickup_datetime', 'tpep_dropoff_datetime',
       'passenger_count', 'trip_distance', 'RatecodeID', 'store_and_fwd_flag',
       'PULocationID', 'DOLocationID', 'payment_type']]
y = ytp[['fare_amount', 'extra', 'mta_tax',
         'tip_amount', 'tolls_amount', 'improvement_surcharge',
       'total_amount', 'congestion_surcharge', 'Airport_fee']]
X = X.rename(columns={
      'VendorID':'VendorID',
      'tpep_pickup_datetime':'pickup_datetime',
      'tpep_dropoff_datetime':'dropoff_datetime',
      'passenger_count':'num_psngr',
      'trip_distance':'trip_distance',
      'RatecodeID':'RatecodeID',
      'store_and_fwd_flag':'dnu',
      'PULocationID':'pickup_LocationID',
      'DOLocationID':'dropoff_LocationID',
      'payment_type':'type_pymt'
    })
y = y[['tip_amount']]

# split into test and train data
split_percent = 10
X_train, X_test, y_train, y_test = train_test_split(X,y,test_size=split_percent/100,random_state=42)

# create new variable to discover k-means
wd_ser = ytp['tpep_pickup_datetime'].dt.weekday + ytp['tpep_pickup_datetime'].dt.hour/24 + ytp['tpep_pickup_datetime'].dt.minute/1440
wd_ser = wd_ser.rename('pickup_day_of_week+time')
ytp = pd.concat([ytp, wd_ser.T], axis=1)
#result = pd.concat([ytp, wd_ser.T], axis=1)
#print(result)

# identify groups using K-Means elbow on a sample
x_label = 'pickup_day_of_week+time'
y_label = 'tip_amount'

clusters = range(1,11)  #calculate K-means clusters from 1-10
#S_x = result.sample(100)#
S_x = ytp.sample(100)
S_x = S_x[[x_label,y_label]] #values of interest

wcss = []
for i in clusters:
  kmeans = KMeans(n_clusters = i, init = 'k-means++', random_state = 9)
  kmeans.fit(S_x)
  wcss.append(kmeans.inertia_)

plt.plot(clusters, wcss)
plt.title('Elbow Method')
plt.xlabel('number of clusters')
plt.ylabel('WCSS')

elbow_clusters = 6

# K-Means clustering to get groups
scatter = ytp.loc[:,[x_label,y_label]]
kmeans = KMeans(n_clusters = elbow_clusters, init = 'k-means++', random_state = 9)
y_kmeans = kmeans.fit_predict(scatter)

# Visualizing
colors = ['red','blue','green','magenta','cyan','yellow']
for i in range(elbow_clusters):
  plt.scatter(scatter.loc[y_kmeans == i, x_label], scatter.loc[y_kmeans == i, y_label], s=100, c = colors[i], label = 'Cluster %d'%i)
plt.title('trip clustering')
plt.xlabel(x_label)
plt.ylabel(y_label)
plt.yscale('log', base=10)
#plt.xscale('log', base=10)
plt.show()